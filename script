
-- data analytics --

use DataWarehouseAnalytics;

select  * from gold.fact_sales;

-- cumulative analysis--
-- calculate the total_sales of a month and running total for month -- 
-- default frame is between unbounded preceding & current row -- 
select order_date,
total_sales,
SUM(total_sales) OVER(ORDER BY order_date) as running_total_sales
FROM
(
SELECT
DATETRUNC(MONTH,order_date) as order_date,
SUM(sales_amount) as total_sales
FROM gold.fact_sales
WHERE order_date is not null
GROUP BY DATETRUNC(MONTH,order_date)
)t

-- partition by year in windows function both the total_sales & running total will be same-- 

select order_date,
total_sales,
SUM(total_sales) OVER(PARTITION BY order_date ORDER BY order_date) as running_total_sales
FROM
(
SELECT
DATETRUNC(MONTH,order_date) as order_date,
SUM(sales_amount) as total_sales
FROM gold.fact_sales
WHERE order_date is not null
GROUP BY DATETRUNC(MONTH,order_date)
)t

-- analysis by year --
-- cumulative analysis--
-- calculate the total_sales of a month and running total for month -- 
-- default frame is between unbounded preceding & current row -- 

select order_date,
total_sales,
SUM(total_sales) OVER(ORDER BY order_date) as running_total_sales,
AVG(avg_price) OVER(ORDER BY order_date) as moving_avg_price
FROM
(
SELECT
DATETRUNC(YEAR,order_date) as order_date,
SUM(sales_amount) as total_sales,
AVG(price) as avg_price
FROM gold.fact_sales
WHERE order_date is not null
GROUP BY DATETRUNC(YEAR,order_date)
)t

-- performance analysis -- comparing the current value to the target value --  current measure - target measure

-- current year sales - previous year sales -- YOY analysis

/* analyse the yearly performance of products by comparing their sales 
to both the average sales performance of the product and the previous year's sales */

SELECT * FROM gold.fact_sales;
SELECT * FROM gold.dim_products;

WITH yearly_product_sales as 
(
SELECT 
YEAR(f.order_date) as order_year,
p.product_name,
SUM(f.sales_amount) as current_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
on f.product_key = p.product_key
where f.order_date is not null
group by YEAR(f.order_date),p.product_name
)
select order_year,
	product_name,
	current_sales,
	AVG(current_sales)OVER(PARTITION BY product_name) as average_sales,
	current_sales - AVG(current_sales)OVER(PARTITION BY product_name) as diff_avg,
	CASE
	WHEN current_sales - AVG(current_sales)OVER(PARTITION BY product_name) > 0 THEN 'Above Avg'
	WHEN current_sales - AVG(current_sales)OVER(PARTITION BY product_name) < 0 THEN 'Below Avg'
	ELSE 'Avg'
	END as avg_change,
	-- year over year Analysis -- 
	LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) as previous_sales,
	current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) as diff_sales,
	CASE
	WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) > 0 THEN 'Increased'
	WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) < 0 THEN 'Decreased'
	ELSE 'No Change'
	END as py_change
FROM yearly_product_sales
order by product_name,order_year;


-- Part to whole analysis --	proportional analysis -- 
-- understand which part is giving higher sales -- 
-- measure / Total(measure) * 100 by dimension
-- (sales / total sales ) * 100 by category
-- ( quantity/ total quantity) * 100 by country

-- which category contributes more to the overall sales -- 

WITH category_sales as (
SELECT category,
SUM(sales_amount) as total_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
on f.product_key = p.product_key
GROUP BY category
)
SELECT 
	category,
	total_sales,
	SUM(total_sales) OVER() as overall_sales,
	CONCAT(ROUND((CAST(total_sales as FLOAT) / SUM(total_sales) OVER() ) * 100,2),'%') as percentage_of_total
FROM category_sales
ORDER BY total_sales DESC;


-- data segmentations -- [measure] by [measure]
/* segment products into cost range and 
count how many products fall into each segment */


WITH product_category as (
SELECT product_key,
	product_number,
	cost,
CASE 
	WHEN cost < 100 THEN 'Below 100'
	WHEN cost between 100 and 500 THEN '100-500'
	WHEN cost between 500 and 1000 THEN '500-1000'
	ELSE 'Above 1000'
	END as cost_range
FROM gold.dim_products
)
SELECT cost_range,
	COUNT(product_key) as total_products
	FROM product_category
	GROUP BY cost_range
	ORDER BY total_products DESC;

/* group customer into 3 segements 
VIP : customer with 12 months of history and spending with more than 5000
Regular : customer with 12 months of history but spending 5000 or less
New : customer with lifespan less than 12 months
and find total number of customer by each group */

SELECT * FROM gold.dim_customers;
SELECT * FROM gold.fact_sales;

WITH customer_spend as 
(
SELECT 
	c.customer_key,
	sum(sales_amount) as total_spending,
	MIN(order_date) as first_order,
	MAX(order_date) as last_order,
	DATEDIFF(MONTH,MIN(order_date),MAX(order_date)) as life_span
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
on f.customer_key = c.customer_key
GROUP BY c.customer_key
)
SELECT customer_segment,
COUNT(customer_key) as total_customers
FROM
(
SELECT customer_key,
CASE
WHEN life_span >= 12 AND total_spending > 5000 THEN 'VIP'
WHEN life_span >= 12 AND total_spending BETWEEN 1000 AND 5000 THEN 'Regular'
ELSE 'New'
END as customer_segment
FROM customer_spend) t
GROUP BY customer_segment
ORDER BY total_customers DESC;





	
